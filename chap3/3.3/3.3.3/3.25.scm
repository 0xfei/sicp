(define (debug . k)
  (define (output k)
    (if (null? k)
      '()
      (begin (newline) (display (car k)) (output (cdr k)))))
  (output k))

(define (make-table same-key?)
  (let ((table '(table)))
    ; is-table
    (define (is-table? t) (and (pair? t) (eq? 'table (car t))))
    ; empty
    (define (empty?) (null? (cdr table)))
    ; findout
    (define (findout k table)
      (define (i-find k l)
        (cond ((null? l) '())
              ((same-key? k (caar l)) (car l))
              (else (i-find k (cdr l)))))
      (i-find k (cdr table)))
    ; lookup
    (define (lookup . k)
      (define (i-find k table)
        (let ((k1 (car k))
              (left (cdr k)))
          (let ((t (findout k1 table)))
            (cond ((null? left) t)
                  ((null? t) t)
                  ((is-table? (cdr t)) (i-find left (cdr t)))
                  (else '())))))
      (i-find k table))
    ; join
    (define (join item table)
      (set-cdr! table (cons item (cdr table))))
    ; parse
    (define (parse k)
      (let ((k1 (car k))
            (k2 (cadr k))
            (k3 (cddr k))
            (left (cdr k)))
        (if (null? k3)
          (begin (set-cdr! k '()) k2)
          (parse left))))
    ; i-insert
    (define (i-insert k v table)
      (let ((k1 (car k))
            (left (cdr k)))
        (let ((t (findout k1 table)))
          (cond ((and (null? left) (pair? t))
                 (set-cdr! t v))
                ((and (null? left) (null? t))
                 (join (cons k1 v) table))
                ((is-table? t)
                 (i-insert left v t))
                (else (let ((new-table '(table)))
                        (i-insert left v new-table)
                        (if (null? t)
                          (join (cons k1 new-table) table)
                          (set-cdr! t new-table))))))
        table))
    ; insert
    (define (insert . k)
      (i-insert k (parse k) table))
    ; insert k v
    (define (insert-kv k v)
      (i-insert k v table))
    ; dispatch
    (define (dispatch m)
      (cond ((eq? m 'lookup) lookup)
            ((eq? m 'insert) insert)
            ((eq? m 'insert-kv) insert-kv)
            (else "Error")))
    ; return
    dispatch))

(define table (make-table (lambda (x y) (equal? x y))))
(define get (table 'lookup))
(define set (table 'insert))

